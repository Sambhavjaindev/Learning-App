
package knowledgehb;

public class KCPlusLearning extends javax.swing.JFrame {

   connect c;
   
    public KCPlusLearning(connect c) {
        initComponents();
        this.c=c;
        this.setLocationRelativeTo(null);
        text.setLineWrap(true);
        this.setTitle("C++ Learning");
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        IntroB = new javax.swing.JButton();
        decisionB = new javax.swing.JButton();
        ifbutton = new javax.swing.JButton();
        ifelseB = new javax.swing.JButton();
        elseifB = new javax.swing.JButton();
        switchB = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel1 = new javax.swing.JLabel();
        jPanel2 = new javax.swing.JPanel();
        arrarB = new javax.swing.JButton();
        stringB = new javax.swing.JButton();
        stringmaniB = new javax.swing.JButton();
        jScrollPane2 = new javax.swing.JScrollPane();
        text = new javax.swing.JTextArea();
        nesterdB = new javax.swing.JButton();
        PointerB = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jPanel4 = new javax.swing.JPanel();
        classobjB = new javax.swing.JButton();
        inheritancB = new javax.swing.JButton();
        oveerloadingB = new javax.swing.JButton();
        PolymorB = new javax.swing.JButton();
        AbstractionB = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jPanel1.setBackground(new java.awt.Color(51, 255, 204));

        jLabel3.setBackground(new java.awt.Color(204, 204, 204));
        jLabel3.setIcon(new javax.swing.ImageIcon(getClass().getResource("/c2.png"))); // NOI18N
        jLabel3.setText("jLabel3");

        IntroB.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        IntroB.setText("Introduction");
        IntroB.setBorderPainted(false);
        IntroB.setContentAreaFilled(false);
        IntroB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                IntroBActionPerformed(evt);
            }
        });

        decisionB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        decisionB.setText("Decision Making");
        decisionB.setBorderPainted(false);
        decisionB.setContentAreaFilled(false);
        decisionB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                decisionBActionPerformed(evt);
            }
        });

        ifbutton.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        ifbutton.setText("C++ if Statement");
        ifbutton.setBorderPainted(false);
        ifbutton.setContentAreaFilled(false);
        ifbutton.setDefaultCapable(false);
        ifbutton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ifbuttonActionPerformed(evt);
            }
        });

        ifelseB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        ifelseB.setText("C++ if else");
        ifelseB.setBorderPainted(false);
        ifelseB.setContentAreaFilled(false);
        ifelseB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ifelseBActionPerformed(evt);
            }
        });

        elseifB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        elseifB.setText("C++ Else - if");
        elseifB.setBorderPainted(false);
        elseifB.setContentAreaFilled(false);
        elseifB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                elseifBActionPerformed(evt);
            }
        });

        switchB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        switchB.setText("C++ Switch");
        switchB.setBorderPainted(false);
        switchB.setContentAreaFilled(false);
        switchB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                switchBActionPerformed(evt);
            }
        });

        jPanel3.setBackground(new java.awt.Color(0, 0, 204));
        jPanel3.setMinimumSize(new java.awt.Dimension(0, 0));
        jPanel3.setPreferredSize(new java.awt.Dimension(261, 2));

        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 159, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2, Short.MAX_VALUE)
        );

        jLabel2.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel2.setText("  Flow Control");

        jLabel1.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel1.setText("  Array and Strings");

        jPanel2.setBackground(new java.awt.Color(0, 0, 204));
        jPanel2.setMinimumSize(new java.awt.Dimension(0, 0));
        jPanel2.setPreferredSize(new java.awt.Dimension(261, 2));

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 192, Short.MAX_VALUE)
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2, Short.MAX_VALUE)
        );

        arrarB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        arrarB.setText("C++ Arrays");
        arrarB.setBorderPainted(false);
        arrarB.setContentAreaFilled(false);
        arrarB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                arrarBActionPerformed(evt);
            }
        });

        stringB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        stringB.setText("C++ Strings");
        stringB.setBorderPainted(false);
        stringB.setContentAreaFilled(false);
        stringB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stringBActionPerformed(evt);
            }
        });

        stringmaniB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        stringmaniB.setText("String Manipulations");
        stringmaniB.setBorderPainted(false);
        stringmaniB.setContentAreaFilled(false);
        stringmaniB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                stringmaniBActionPerformed(evt);
            }
        });

        text.setEditable(false);
        text.setBackground(new java.awt.Color(204, 204, 204));
        text.setColumns(20);
        text.setFont(new java.awt.Font("Monospaced", 1, 18)); // NOI18N
        text.setRows(5);
        text.setWrapStyleWord(true);
        jScrollPane2.setViewportView(text);

        nesterdB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        nesterdB.setText("C++ Nested If");
        nesterdB.setBorderPainted(false);
        nesterdB.setContentAreaFilled(false);
        nesterdB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nesterdBActionPerformed(evt);
            }
        });

        PointerB.setFont(new java.awt.Font("Tahoma", 0, 20)); // NOI18N
        PointerB.setText("Pointers");
        PointerB.setBorderPainted(false);
        PointerB.setContentAreaFilled(false);
        PointerB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PointerBActionPerformed(evt);
            }
        });

        jLabel4.setFont(new java.awt.Font("Tahoma", 1, 18)); // NOI18N
        jLabel4.setText(" C++ Object Oriented");

        jPanel4.setBackground(new java.awt.Color(0, 0, 204));
        jPanel4.setPreferredSize(new java.awt.Dimension(261, 2));

        javax.swing.GroupLayout jPanel4Layout = new javax.swing.GroupLayout(jPanel4);
        jPanel4.setLayout(jPanel4Layout);
        jPanel4Layout.setHorizontalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanel4Layout.setVerticalGroup(
            jPanel4Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2, Short.MAX_VALUE)
        );

        classobjB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        classobjB.setText("C++ Classes & Objects");
        classobjB.setBorderPainted(false);
        classobjB.setContentAreaFilled(false);
        classobjB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                classobjBActionPerformed(evt);
            }
        });

        inheritancB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        inheritancB.setText("C++ Inheritance");
        inheritancB.setBorderPainted(false);
        inheritancB.setContentAreaFilled(false);
        inheritancB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inheritancBActionPerformed(evt);
            }
        });

        oveerloadingB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        oveerloadingB.setText("C++ Overloading");
        oveerloadingB.setBorderPainted(false);
        oveerloadingB.setContentAreaFilled(false);
        oveerloadingB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                oveerloadingBActionPerformed(evt);
            }
        });

        PolymorB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        PolymorB.setText("C++ Polymorphism");
        PolymorB.setBorderPainted(false);
        PolymorB.setContentAreaFilled(false);
        PolymorB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PolymorBActionPerformed(evt);
            }
        });

        AbstractionB.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        AbstractionB.setText("C++ Abstraction");
        AbstractionB.setBorderPainted(false);
        AbstractionB.setContentAreaFilled(false);
        AbstractionB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AbstractionBActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                        .addComponent(ifelseB)
                        .addComponent(elseifB)
                        .addComponent(switchB)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(IntroB)
                        .addComponent(ifbutton)
                        .addComponent(decisionB)
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, 159, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 182, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(jLabel4, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jPanel4, javax.swing.GroupLayout.DEFAULT_SIZE, 215, Short.MAX_VALUE)
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, 192, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addComponent(classobjB, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(stringmaniB)
                        .addComponent(nesterdB)
                        .addComponent(PointerB)
                        .addComponent(inheritancB)
                        .addComponent(arrarB)
                        .addComponent(stringB))
                    .addComponent(oveerloadingB)
                    .addComponent(PolymorB)
                    .addComponent(AbstractionB))
                .addGap(24, 24, 24)
                .addComponent(jScrollPane2))
            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, jPanel1Layout.createSequentialGroup()
                .addGap(113, 113, 113)
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 767, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(177, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 189, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel1Layout.createSequentialGroup()
                        .addComponent(IntroB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 23, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, 0)
                        .addComponent(jPanel3, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(decisionB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ifbutton)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(ifelseB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(elseifB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(nesterdB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(switchB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel1)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(arrarB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stringB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(stringmaniB, javax.swing.GroupLayout.PREFERRED_SIZE, 31, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(PointerB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel4, javax.swing.GroupLayout.PREFERRED_SIZE, 34, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPanel4, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(classobjB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(inheritancB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(oveerloadingB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(PolymorB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(AbstractionB, javax.swing.GroupLayout.DEFAULT_SIZE, 35, Short.MAX_VALUE)
                        .addContainerGap())
                    .addComponent(jScrollPane2)))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 0, Short.MAX_VALUE)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, 0))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ifbuttonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ifbuttonActionPerformed
               ifbutton.setContentAreaFilled(true);
            elseifB.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
        IntroB.setContentAreaFilled(false);
        PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("There are four different types of if statement in C++. These are:\n 1 Simple if Statement\n" +
" 2 if-else Statement\n" +
" 3 Nested if-else Statement\n" +
" 4 else-if Ladder");
       text.append("\n\nThe basic format of if statement is:");
       text.append("\nSyntax:");
       text.append("\nif(test_expression)\n" +
"{\n" +
"    statement 1;\n" +
"    statement 2;\n" +
"    ...\n" +
"}");
       text.append("\n\nProgram  :\n #include <iostream.h>\n" +
"void main()\n" +
"{\n" +
" int a = 15, b = 20;\n" +
"\n" +
" if (b > a) {\n" +
" cout << \"b is greater\" << endl;\n" +
" }\n" +
" getch();\n" +
"}");
       text.append("\n Output\n b is greater");
        text.setCaretPosition(0);
    }//GEN-LAST:event_ifbuttonActionPerformed

    private void ifelseBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ifelseBActionPerformed
            ifbutton.setContentAreaFilled(false);
            elseifB.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(true);
        IntroB.setContentAreaFilled(false);
        PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("If else statements in C++ is also used to control the program flow based on some condition, only the difference is: it's used to execute some statement code block if the expression is evaluated to true, otherwise executes else statement code block.");
        text.append("\n \n Syntax :\nif(test_expression)\n" +
"{\n" +
"   //execute your code\n" +
"}\n" +
"else\n" +
"{\n" +
"   //execute your code\n" +
"}");
          text.append("\n\nProgram  :\n\n #include <iostream.h>\n" +
"void main()\n" +
"{\n" +
" int a = 20, b = 15;\n" +
" if (b > a) {\n" +
" cout << \"b is greater\" << endl;\n" +
" }\n else {  \n" +
"    cout << \"a is greater\" << endl;\n" +
"  } " +
" getch();\n" +
"}");
    text.append("\n\nOUTPUT :  a is greater");
     text.setCaretPosition(0);
    }//GEN-LAST:event_ifelseBActionPerformed

    private void IntroBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_IntroBActionPerformed
        IntroB.setContentAreaFilled(true);
        ifbutton.setContentAreaFilled(false);
            elseifB.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
        text.setText("C++ is a multi-paradigm programming language that supports object-oriented programming (OOP), created by Bjarne Stroustrup in 1983 at Bell Labs, C++ is an extension(superset) of C programming and the programs are written in C language can run in C++ compilers.");
     text.append("\n \n Uses of C++ \n\n C++ is used by any programmers of different types and coming from different fields. C++ is mostly used to write device driver programs, system software, and applications that depend on direct hardware manipulation under real-time constraints. It is also used to teach the basics of object-oriented features because it is simple and is also used in the fields of research. Also, many primary user interfaces and system files of Windows and Macintosh are written using C++. So, C++ is a popular, strong and frequently used programming language of this modern programming era.\n" );
      text.setCaretPosition(0);
    }//GEN-LAST:event_IntroBActionPerformed

    private void elseifBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_elseifBActionPerformed
       elseifB.setContentAreaFilled(true);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("else if statements in C++ is like another if condition, it's used in a program when if statement having multiple decisions.It is also called as Ladder-If statements");
        text.append("\n\nSyntax: ");
        text.append("\nif(test_expression)\n" +
"{\n" +
"   //execute your code\n" +
"}\n" +
"else if(test_expression n)\n" +
"{\n" +
"   //execute your code\n" +
"}\n" +
"else\n" +
"{\n" +
"   //execute your code\n" +
"}");
        text.append("\n\nEXAMPLE :\n#include <iostream.h>\n" +
"int main() \n" +
"{\n" +
"    int number;\n" +
"    cout << \"Enter an integer: \";\n" +
"    cin >> number;\n" +
"    if ( number > 0)\n" +
"    {\n" +
"        cout << \"You entered a positive integer: \" << number << endl;\n" +
"    }\n" +
"    else if (number < 0)\n" +
"    {\n" +
"        cout<<\"You entered a negative integer: \" << number << endl;\n" +
"    }\n" +
"    else\n" +
"    {\n" +
"        cout << \"You entered 0.\" << endl;\n" +
"    }\n" +
"    cout << \"This line is always printed.\";\n" +
"    return 0;\n" +
"}");
        text.append("\n OUTPUT :\nEnter an integer: 0\n" +
"You entered 0.\n" +
"This line is always printed.");
         text.setCaretPosition(0);
    }//GEN-LAST:event_elseifBActionPerformed

    private void decisionBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_decisionBActionPerformed
             elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(true);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
      text.setText("There comes situations in real life when we need to make some decisions and based on these decisions, we decide what should we do next. Similar situations arises in programming also where we need to make some decisions and based on these decision we will execute the next block of code.\n" +
"\n" +
"Decision making statements in programming languages decides the direction of flow of program execution. Decision making statements available in C++ are:\n" +
"\n" +
"if statement\n" +
"if..else statements\n" +
"nested if statements\n" +
"if-else-if ladder\n" +
"switch statements");
       text.setCaretPosition(0);
    }//GEN-LAST:event_decisionBActionPerformed

    private void switchBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_switchBActionPerformed
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(true);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("The C++ switch statement is used when you have multiple possibilities for the if statement.");
        text.append("\nSYNTAX :\n\nswitch(variable)\n" +
"  {\n" +
"  case 1:\n" +
"   //execute your code\n" +
"  break;\n" +
"\n" +
"  case n:\n" +
"   //execute your code\n" +
"  break;\n" +
"\n" +
"  default:\n" +
"   //execute your code\n" +
"  break;\n" +
"  }");
        text.append("\nAfter the end of each block it is necessary to insert a break statement because if the programmers do not use the break statement, all consecutive blocks of codes will get executed from each and every case onwards after matching the case block.");
        text.append("\n\nPROGRAM :\n#include <iostream.h>\n" +
"int main()\n" +
"{\n" +
"    char o;\n" +
"    float num1, num2;\n" +
"    cout << \"Enter an operator (+, -, *, /): \";\n" +
"    cin >> o;\n" +
"    cout << \"Enter two operands: \";\n" +
"    cin >> num1 >> num2;\n" +
"    \n" +
"    switch (o) \n" +
"    {\n" +
"        case '+':\n" +
"            cout << num1 << \" + \" << num2 << \" = \" << num1+num2;\n" +
"            break;\n" +
"        case '-':\n" +
"            cout << num1 << \" - \" << num2 << \" = \" << num1-num2;\n" +
"            break;\n" +
"        case '*':\n" +
"            cout << num1 << \" * \" << num2 << \" = \" << num1*num2;\n" +
"            break;\n" +
"        case '/':\n" +
"            cout << num1 << \" / \" << num2 << \" = \" << num1/num2;\n" +
"            break;\n" +
"        default:\n" +
"            // operator is doesn't match any case constant (+, -, *, /)\n" +
"            cout << \"Error! operator is not correct\";\n" +
"            break;\n" +
"    }\n" +
"    \n" +
"    return 0;\n" +
"}");
        text.append("\n\nOUTPUT :\nEnter an operator (+, -, *, /): +\n" +
"+\n" +
"Enter two operands: 2.3\n" +
"4.5\n" +
"2.3 + 4.5 = 6.8");
         text.setCaretPosition(0);
    }//GEN-LAST:event_switchBActionPerformed

    private void arrarBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_arrarBActionPerformed
        arrarB.setContentAreaFilled(true);
         elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("An array is collection of items stored at continuous memory locations.\n" +
"\n\nWhy do we need arrays?\n" +
"We can use normal variables (v1, v2, v3, ..) when we have small number of objects, but if we want to store large number of instances, it becomes difficult to manage them with normal variables. The idea of array is to represent many instances in one variable.");
text.append("\n\nDefine an Array in C++\ntype arrayName [ arraySize ];\n" +
"An array type can be any valid C++ data types, and array size must be an integer constant greater than zero.\n" +
"\n" +
"Example\ndouble salary[15];");
text.append("\n\nInitializing Arrays\n" +
"You can initialize C++ array elements either one by one or using a single statement as follows −\n" +
"double balance[5] = {1000.0, 2.0, 3.4, 17.0, 50.0};");
text.append("\n\nIf you omit the size of the array, an array just big enough to hold the initialization is created. Therefore, if you write −\n" +
"double balance[] = {1000.0, 2.0, 3.4, 17.0, 50.0};");
text.append("\n\nbalance[4] = 50.0;\n" +
"The above statement assigns element number 5th in the array a value of 50.0. Array with 4th index will be 5th, i.e., last element because all arrays have 0 as the index of their first element which is also called base index.");
text.append("\n\nProgram  :\n#include <iostream.h>\n" +
"#include <iomanip.h>\n" +
"using std::setw;\n" +
" \n" +
"int main () {\n" +
"   int n[ 10 ]; // n is an array of 10 integers\n" +
" \n" +
"   // initialize elements of array n to 0          \n" +
"   for ( int i = 0; i < 10; i++ ) {\n" +
"      n[ i ] = i + 100; // set element at location i to i + 100\n" +
"   }\n" +
"   cout << \"Element\" << setw( 13 ) << \"Value\" << endl;\n" +
"   // output each array element's value                      \n" +
"   for ( int j = 0; j < 10; j++ ) {\n" +
"      cout << setw( 7 )<< j << setw( 13 ) << n[ j ] << endl;\n" +
"   }\n" +
"   return 0;\n" +
"}");
text.append("\n\nOUTPUT:\nElement        Value\n" +
"      0          100\n" +
"      1          101\n" +
"      2          102\n" +
"      3          103\n" +
"      4          104\n" +
"      5          105\n" +
"      6          106\n" +
"      7          107\n" +
"      8          108\n" +
"      9          109");
 text.setCaretPosition(0);

    }//GEN-LAST:event_arrarBActionPerformed

    private void stringBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stringBActionPerformed
     stringB.setContentAreaFilled(true);
      elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("There are two ways to declare a string in C++:\n" +
"\n" +
"Through an array of characters:\n" +
"char greeting[6]={'H', 'e', 'l', 'l', 'o', '\\0'};\nchar greeting[] = \"Hello\";\n" +
"\nThrough pointers:\n" +
"char *greeting;");
       text.append("\n\nProgram\n\n#include <iostream.h>\n" +
"int main () {\n" +
"\n" +
"   char greeting[6] = {'H', 'e', 'l', 'l', 'o', '\\0'};\n" +
"   cout << \"Greeting message: \";\n" +
"   cout << greeting << endl;\n" +
"\n" +
"   return 0;\n" +
"}");
       text.append("\n\nOUTPUT :\nGreeting message: Hello");
        text.setCaretPosition(0);
    }//GEN-LAST:event_stringBActionPerformed

    private void stringmaniBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stringmaniBActionPerformed
       elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        nesterdB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(true);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("C++ supports a wide range of functions that manipulate null-terminated strings −\n" +
"\n" +
"Sr.No \n "+
"1	" +
"strcpy(s1, s2);\n" +
"\n" +
"Copies string s2 into string s1.\n" +
"\n" +
"2	" +
"strcat(s1, s2);\n" +
"\n" +
"Concatenates string s2 onto the end of string s1.\n" +
"\n" +
"3	" +
"strlen(s1);\n" +
"\n" +
"Returns the length of string s1.\n" +
"\n" +
"4	" +
"strcmp(s1, s2);\n" +
"\n" +
"Returns 0 if s1 and s2 are the same; less than 0 if s1<s2; greater than 0 if s1>s2.\n" +
"\n" +
"5	" +
"strchr(s1, ch);\n" +
"\n" +
"Returns a pointer to the first occurrence of character ch in string s1.\n" +
"\n" +
"6	" +
"strstr(s1, s2);\n" +
"\n" +
"Returns a pointer to the first occurrence of string s2 in string s1.");
        text.append("\n\n\tImportant Functions supported By String Class  :"
                + ""
                + ""
                + "");
        text.append("\n\nappend(): This function appends a part of a string to another string\n" +
"assign():This function assigns a partial string\n" +
"at(): This function obtains the character stored at a specified location\n" +
"begin(): This function returns a reference to the start of the string\n" +
"capacity(): This function gives the total element that can be stored\n" +
"compare(): This function compares a string against the invoking string\n" +
"empty(): This function returns true if the string is empty\n" +
"end(): This function returns a reference to the end of the string\n" +
"erase(): This function removes character as specified\n" +
"find(): This function searches for the occurrence of a specified substring\n" +
"length(): It gives the size of a string or the number of elements of a string\n" +
"swap(): This function swaps the given string with the invoking one");
        text.append("\n  \n To use Strings function u have to include<string.h> header file. This header file contains all String methods ");
        text.append("\n\n\t Program  :\n#include <iostream.h>\n" +
"#include <string.h>\n" +
"int main () {\n" +
"\n" +
"   char str1[10] = \"Hello\";\n" +
"   char str2[10] = \"World\";\n" +
"   char str3[10];\n" +
"   int  len ;\n" +
"\n" +
"   // copy str1 into str3\n" +
"   strcpy( str3, str1);\n" +
"   cout << \"strcpy( str3, str1) : \" << str3 << endl;\n" +
"\n" +
"   // concatenates str1 and str2\n" +
"   strcat( str1, str2);\n" +
"   cout << \"strcat( str1, str2): \" << str1 << endl;\n" +
"\n" +
"   // total lenghth of str1 after concatenation\n" +
"   len = strlen(str1);\n" +
"   cout << \"strlen(str1) : \" << len << endl;\n" +
"\n" +
"   return 0;\n" +
"}");
        text.append("\nOutput :\nstrcpy( str3, str1) : Hello\n" +
"strcat( str1, str2): HelloWorld\n" +
"strlen(str1) : 10");
         text.setCaretPosition(0);
    }//GEN-LAST:event_stringmaniBActionPerformed

    private void nesterdBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nesterdBActionPerformed
        nesterdB.setContentAreaFilled(true);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("A nested if is an if statement that is the target of another if statement. Nested if statements means an if statement inside another if statement. Yes, C++ allows us to nest if statements within if statements. i.e, we can place an if statement inside another if statement.\n" +
"\nSyntax:\n" +
"\n" +
"if (condition1) \n" +
"{\n" +
"   // Executes when condition1 is true\n" +
"   if (condition2) \n" +
"   {\n" +
"      // Executes when condition2 is true\n" +
"   }\n" +
"}");
        text.append("\n Program \n #include<iostream.h>;\nint main() \n" +
"    { \n" +
"        int i = 10; \n" +
"   \n" +
"        if (i == 10) \n" +
"        { \n" +
"            // First if statement \n" +
"            if (i < 15) \n" +
"               cout<<\"i is smaller than 15\"; \n" +
"   \n" +
"            // Nested - if statement \n" +
"            // Will only be executed if statement above \n" +
"            // it is true \n" +
"            if (i < 12) \n" +
"                cout<<\"i is smaller than 12 too\"; \n" +
"            else\n" +
"                cout<<\"i is greater than 15\"; \n" +
"        } \n" +
"  \n" +
"        return 0; \n" +
"    } \n" +
"\nOutput:\n" +
"i is smaller than 15\n" +
"i is smaller than 12 too");
         text.setCaretPosition(0);
    }//GEN-LAST:event_nesterdBActionPerformed

    private void PointerBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PointerBActionPerformed
     nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(true);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("Some C++ tasks are performed more easily with pointers, and other C++ tasks, such as dynamic memory allocation, cannot be performed without them.\n" +
"\n" +
"As you know every variable is a memory location and every memory location has its address defined which can be accessed using ampersand (&) operator which denotes an address in memory. Consider the following which will print the address of the variables defined −");
text.append("\n\n#include <iostream.h>\n" +
"int main () {\n" +
"   int  var1;\n" +
"   char var2[10];\n" +
"\n" +
"   cout << \"Address of var1 variable: \";\n" +
"   cout << &var1 << endl;\n" +
"\n" +
"   cout << \"Address of var2 variable: \";\n" +
"   cout << &var2 << endl;\n" +
"\n" +
"   return 0;\n" +
"}");   
text.append("\n\nOutput :\nAddress of var1 variable: 0xbfebd5c0\n" +
"Address of var2 variable: 0xbfebd5b6");
text.append("\n\nWhat are Pointers?\n" +
"A pointer is a variable whose value is the address of another variable. Like any variable or constant, you must declare a pointer before you can work with it. The general form of a pointer variable declaration is −\n" +
"\n" +
"type *var-name;");
text.append("\n\nHere, type is the pointer's base type; it must be a valid C++ type and var-name is the name of the pointer variable. The asterisk you used to declare a pointer is the same asterisk that you use for multiplication. However, in this statement the asterisk is being used to designate a variable as a pointer. Following are the valid pointer declaration −\n" +
"\n" +
"int    *ip;    // pointer to an integer\n" +
"double *dp;    // pointer to a double\n" +
"float  *fp;    // pointer to a float\n" +
"char   *ch     // pointer to character\n" +
"\nThe actual data type of the value of all pointers, whether integer, float, character, or otherwise, is the same, a long hexadecimal number that represents a memory address. The only difference between pointers of different data types is the data type of the variable or constant that the pointer points to.");
 text.setCaretPosition(0);
    }//GEN-LAST:event_PointerBActionPerformed

    private void oveerloadingBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_oveerloadingBActionPerformed
       oveerloadingB.setContentAreaFilled(true);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
         nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
        text.setText("If we create two or more members having the same name but different in number or type of parameter, it is known as C++ overloading. In C++, we can overload:" +
"\n" +
"methods,\n" +
"constructors, and\n" +
"indexed properties\n" +
"It is because these members have parameters only.\n" +
"\n" +
"Types of overloading in C++ are:\n" +
"Function overloading\n" +
"Operator overloading");
        text.append("\n\nC++ Function Overloading\n" +
"\nFunction Overloading is defined as the process of having two or more function with the same name, but different in parameters is known as function overloading in C++. In function overloading, the function is redefined by using either different types of arguments or a different number of arguments. It is only through these differences compiler can differentiate between the functions.\n" +
"\n" +
"\n" +
"The advantage of Function overloading is that it increases the readability of the program because you don't need to use different names for the same action.\n" +
"\n" +
"C++ Function Overloading Example\n" +
"Let's see the simple example of function overloading where we are changing number of arguments of add() method.\n" +
"\n" +
"// program of function overloading when number of arguments vary.\n" +
"\n" +
"#include <iostream>    \n" +
"using namespace std;    \n" +
"class Cal {    \n" +
"    public:    \n" +
"static int add(int a,int b){      \n" +
"        return a + b;      \n" +
"    }      \n" +
"static int add(int a, int b, int c)      \n" +
"    {      \n" +
"        return a + b + c;      \n" +
"    }      \n" +
"};     \n" +
"int main(void) {    \n" +
"    Cal C;                                                    //     class object declaration.   \n" +
"    cout<<C.add(10, 20)<<endl;      \n" +
"    cout<<C.add(12, 20, 23);     \n" +
"   return 0;    \n" +
"}    ");
        text.append("\n\nOutput:\n" +
"30\n" +
"55");
         text.setCaretPosition(0);
    }//GEN-LAST:event_oveerloadingBActionPerformed

    private void classobjBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_classobjBActionPerformed
        nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(true);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
           oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("C++ is an object-oriented programming language.\n" +
"\n" +
"Everything in C++ is associated with classes and objects, along with its attributes and methods. For example: in real life, a car is an object. The car has attributes, such as weight and color, and methods, such as drive and brake.\n" +
"\n" +
"Attributes and methods are basically variables and functions that belongs to the class. These are often referred to as \"class members\".\n" +
"\n" +
"A class is a user-defined data type that we can use in our program, and it works as an object constructor, or a \"blueprint\" for creating objects.\n" +
"");
        text.append("Create a Class\n" +
"To create a class, use the class keyword:" +
"\n" +
"\nExample\n" +
"Create a class called \"MyClass\":\n" +
"\n" +
"class MyClass {       // The class\n" +
"  public:             // Access specifier\n" +
"    int myNum;        // Attribute (int variable)\n" +
"    string myString;  // Attribute (string variable)\n" +
"};");
        text.append("\n\nExample explained\n" +
" 1 The class keyword is used to create a class called MyClass.\n" +
" 2 The public keyword is an access specifier, which specifies that members (attributes and methods) of the class are accessible from outside the class. You will learn more about access specifiers later.\n" +
" 3 Inside the class, there is an integer variable myNum and a string variable myString. When variables are declared within a class, they are called attributes.\n" +
" 4 At last, end the class definition with a semicolon ;.");
        text.append("\n\nCreate an Object\n" +
"In C++, an object is created from a class. We have already created the class named MyClass, so now we can use this to create objects.\n" +
"\n" +
"To create an object of MyClass, specify the class name, followed by the object name.\n" +
"To access the class attributes (myNum and myString), use the dot syntax (.) on the object:");
        text.append("\n\n   Program  : \n#include <iostream.h>\n" +
"\n" +
"class Car {\n" +
"  public:\n" +
"    string brand;\n" +
"    string model;\n" +
"    int year;\n" +
"};\n" +
"\n" +
"int main() {\n" +
"  Car carObj1;\n" +
"  carObj1.brand = \"BMW\";\n" +
"  carObj1.model = \"X5\";\n" +
"  carObj1.year = 1999;\n" +
"\n" +
"  Car carObj2;\n" +
"  carObj2.brand = \"Ford\";\n" +
"  carObj2.model = \"Mustang\";\n" +
"  carObj2.year = 1969;\n" +
"\n" +
" cout << carObj1.brand << \" \" << carObj1.model << \" \" << carObj1.year ;\n" +
"  cout << \"\\n\"<< carObj2.brand << \" \" << carObj2.model << \" \" << carObj2.year ;\n" +
"  return 0;\n" +
"}");
        text.append("\n Output  :\nBMW X5 1999\n" +
"Ford Mustang 1969");
         text.setCaretPosition(0);
    }//GEN-LAST:event_classobjBActionPerformed

    private void inheritancBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inheritancBActionPerformed
        nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(true);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
        oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(false);
        text.setText("When creating a class, instead of writing completely new data members and member functions, the programmer can designate that the new class should inherit the members of an existing class. This existing class is called the base class, and the new class is referred to as the derived class.");
        text.append("\n\nAdvantage of C++ Inheritance\n" +
"Code reusability: Now you can reuse the members of your parent class. So, there is no need to define the member again. So less code is required in the class.");
        text.append("\n \nIn C++, inheritance is a process in which one object acquires all the properties and behaviors of its parent object automatically. In such way, you can reuse, extend or modify the attributes and behaviors which are defined in other class.\n" +
"\n" +
"In C++, the class which inherits the members of another class is called derived class and the class whose members are inherited is called base class. The derived class is the specialized class for the base class.\n" +
"\n" +
"Types Of Inheritance\n" +
"C++ supports five types of inheritance:\n" +
"\n" +
" 1 Single inheritance\n" +
" 2 Multiple inheritance\n" +
" 3 Hierarchical inheritance\n" +
" 4 Multilevel inheritance\n" +
" 5 Hybrid inheritance");
        text.append("\n\nBase and Derived Classes\n" +
"A class can be derived from more than one classes, which means it can inherit data and functions from multiple base classes. To define a derived class, we use a class derivation list to specify the base class(es). A class derivation list names one or more base classes and has the form −\n" +
"\n" +
"class derived-class: access-specifier base-class\n" +
"\nWhere access-specifier is one of public, protected, or private, and base-class is the name of a previously defined class. If the access-specifier is not used, then it is private by default.");
        text.append("\n\nC++ Programming Multilevel Inheritance Syntax\n" +
"class A // base class\n" +
"{\n" +
"     ...........\n" +
"};\n" +
"class B : acess_specifier A // derived class\n" +
"{\n" +
"     ...........\n" +
" } ;\n" +
" class C : access_specifier B // derived from derived class B\n" +
" {\n" +
"     ...........\n" +
" } ;");
text.append("\n\nProgram  :\n#include <iostream.h>\n" +
"class base //single base class\n" +
"{\n" +
" 	public:\n" +
" 	int x;\n" +
" 	void getdata()\n" +
" 	{\n" +
"    	cout << \"Enter value of x= \"; cin >> x;\n" +
" 	}\n" +
"};\n" +
"class derive1 : public base // derived class from base class\n" +
"{\n" +
" 	public:\n" +
" 	int y;\n" +
" 	void readdata()\n" +
" 	{\n" +
" 	    cout << \"\\nEnter value of y= \"; cin >> y;\n" +
" 	}\n" +
"};\n" +
"class derive2 : public derive1   // derived from class derive1\n" +
"{\n" +
" 	private:\n" +
" 	int z;\n" +
" 	public:\n" +
" 	void indata()\n" +
" 	{\n" +
"    	cout << \"\\nEnter value of z= \"; cin >> z;\n" +
" 	}\n" +
" 	void product()\n" +
" 	{\n" +
" 	    cout << \"\\nProduct= \" << x * y * z;\n" +
" 	}\n" +
"};\n" +
"int main()\n" +
"{\n" +
"     derive2 a;      //object of derived class\n" +
"     a.getdata();\n" +
"     a.readdata();\n" +
"     a.indata();\n" +
"     a.product();\n" +
"     return 0;\n" +
"}              	//end of program\n" +
"\nOutput\n" +
"\n" +
"Enter value of x= 2\n" +
"\n" +
"Enter value of y= 3\n" +
"\n" +
"Enter value of z= 3\n" +
"\n" +
"Product= 18");
         text.setCaretPosition(0);
    }//GEN-LAST:event_inheritancBActionPerformed

    private void AbstractionBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AbstractionBActionPerformed
         oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(true);
        PolymorB.setContentAreaFilled(false);
         nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
        text.setText("Data Abstraction in C++\n" +
"\nData Abstraction is a process of providing only the essential details to the outside world and hiding the internal details, i.e., representing only the essential details in the program.\n" +
"Data Abstraction is a programming technique that depends on the seperation of the interface and implementation details of the program.\n" +
"\nLet's take a real life example of AC, which can be turned ON or OFF, change the temperature, change the mode, and other external components such as fan, swing. But, we don't know the internal details of the AC, i.e., how it works internally. Thus, we can say that AC seperates the implementation details from the external interface.\n" +
"\nC++ provides a great level of abstraction. For example, pow() function is used to calculate the power of a number without knowing the algorithm the function follows.\n" +
"In C++ program if we implement class with private and public members then it is an example of data abstraction.\n" +
"\n" +
"Data Abstraction can be achieved in two ways:\n" +
"Abstraction using classes\n" +
"Abstraction in header files.");
        text.append("\n\nAbstraction using classes: An abstraction can be achieved using classes. A class is used to group all the data members and member functions into a single unit by using the access specifiers. A class has the responsibility to determine which data member is to be visible outside and which is not.");
        text.append("\n\nAbstraction using header files :An another type of abstraction is header file. For example, pow() function available is used to calculate the power of a number without actually knowing which algorithm function uses to calculate the power. Thus, we can say that header files hides all the implementation details from the user.\n" +
"\n" +
"Access Specifiers Implement Abstraction:\n" +
"\n" +
"Public specifier: When the members are declared as public, members can be accessed anywhere from the program.\n" +
"\nPrivate specifier: When the members are declared as private, members can only be accessed only by the member functions of the class.\n" +
"\nLet's see a simple example of abstraction in header files.\n" +
"// program to calculate the power of a number.\n" +
"\n" +
"#include <iostream>  \n" +
"#include<math.h>  \n" +
"using namespace std;  \n" +
"int main()  \n" +
"{    \n" +
" int n = 4;  \n" +
"   int power = 3;  \n" +
"   int result = pow(n,power);         // pow(n,power) is the  power function  \n" +
"   std::cout << \"Cube of n is : \" <<result<< std::endl;  \n" +
"   return 0;  \n" +
"}  ");
        text.append("\nOutput:\n" +
"\n" +
"Cube of n is : 64");
        text.append("\n\nLet's see a simple example of data abstraction using classes.\n" +
"\n" +
"#include <iostream.h>    \n" +
"using namespace std;    \n" +
" class Sum    \n" +
"{    \n" +
"private: int x, y, z; // private variables  \n" +
"public:    \n" +
"void add()    \n" +
"{    \n" +
"cout<<\"Enter two numbers: \";    \n" +
"cin>>x>>y;    \n" +
"z= x+y;    \n" +
"cout<<\"Sum of two number is: \"<<z<<endl;    \n" +
"}    \n" +
"};    \n" +
"int main()    \n" +
"{    \n" +
"Sum sm;    \n" +
"sm.add();    \n" +
"return 0;    \n" +
"}    ");
        text.append("\n\nOutput:\n" +
"\n" +
"Enter two numbers:\n" +
"3\n" +
"6\n" +
"Sum of two number is: 9\n" +
"In the above example, abstraction is achieved using classes. A class 'Sum' contains the private members x, y and z are only accessible by the member functions of the class.\n" );
 text.append("\n\nAdvantages Of Abstraction:\n" +
"Implementation details of the class are protected from the inadvertent user level errors.\n" +
"A programmer does not need to write the low level code.\n" +
"Data Abstraction avoids the code duplication, i.e., programmer does not have to undergo the same tasks every time to perform the similar operation.\n" +
"The main aim of the data abstraction is to reuse the code and the proper partitioning of the code across the classes.\n" +
"Internal implementation can be changed without affecting the user level code.")  ;
  text.setCaretPosition(0);
    }//GEN-LAST:event_AbstractionBActionPerformed

    private void PolymorBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PolymorBActionPerformed
         oveerloadingB.setContentAreaFilled(false);
        AbstractionB.setContentAreaFilled(false);
        PolymorB.setContentAreaFilled(true);
         nesterdB.setContentAreaFilled(false);
        elseifB.setContentAreaFilled(false);
           IntroB.setContentAreaFilled(false);
        ifbutton.setContentAreaFilled(false);
       ifelseB.setContentAreaFilled(false);
      PointerB.setContentAreaFilled(false);
        classobjB.setContentAreaFilled(false);
        inheritancB.setContentAreaFilled(false);
        stringB.setContentAreaFilled(false);
        stringmaniB.setContentAreaFilled(false);
        switchB.setContentAreaFilled(false);
        decisionB.setContentAreaFilled(false);
        arrarB.setContentAreaFilled(false);
      
        text.setText("Polymorphism in C++\n" +
"\nThe word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form.\n" +
"\nReal life example of polymorphism, a person at the same time can have different characteristic. Like a man at the same time is a father, a husband, an employee. So the same person posses different behavior in different situations. This is called polymorphism.\n" +
"\nPolymorphism is considered as one of the important features of Object Oriented Programming.\n" +
"In C++ polymorphism is mainly divided into two types:\n" +
"\n" +
"Compile time Polymorphism\n" +
"Runtime Polymorphism");
        text.append("\nCompile time polymorphism: This type of polymorphism is achieved by function overloading or operator overloading.");
        text.append("\n\nFunction Overloading: When there are multiple functions with same name but different parameters then these functions are said to be overloaded. Functions can be overloaded by change in number of arguments or/and change in type of arguments.");
        text.append("\n\nOperator Overloading: C++ also provide option to overload operators. For example, we can make the operator (‘+’) for string class to concatenate two strings. We know that this is the addition operator whose task is to add two operands. So a single operator ‘+’ when placed between integer operands , adds them and when placed between string operands, concatenates them.");
        text.append("\n\nclass Complex { \n" +
"private: \n" +
"    int real, imag; \n" +
"public: \n" +
"    Complex(int r = 0, int i =0)  {real = r;   imag = i;} \n" +
"       \n" +
"    // This is automatically called when '+' is used with \n" +
"    // between two Complex objects \n" +
"    Complex operator + (Complex const &obj) { \n" +
"         Complex res; \n" +
"         res.real = real + obj.real; \n" +
"         res.imag = imag + obj.imag; \n" +
"         return res; \n" +
"    } \n" +
"    void print() { cout << real << \" + i\" << imag << endl; } \n" +
"}; \n" +
"   \n" +
"int main() \n" +
"{ \n" +
"    Complex c1(10, 5), c2(2, 4); \n" +
"    Complex c3 = c1 + c2; // An example call to \"operator+\" \n" +
"    c3.print(); \n" +
"} \n" +
"\nOutput:\n" +
"\n" +
"12 + i9");
        text.append("\n\nRuntime polymorphism: This type of polymorphism is achieved by Function Overriding.\n" +
"Function overriding on the other hand occurs when a derived class has a definition for one of the member functions of the base class. That base function is said to be overridden.");
        text.append("#include <iostream.h> \n" +
"class base \n" +
"{ \n" +
"public: \n" +
"    virtual void print () \n" +
"    { cout<< \"print base class\" <<endl; } \n" +
"   \n" +
"    void show () \n" +
"    { cout<< \"show base class\" <<endl; } \n" +
"}; \n" +
"   \n" +
"class derived:public base \n" +
"{ \n" +
"public: \n" +
"    void print () //print () is already virtual function in derived class, we could also declared as virtual void print () explicitly \n" +
"    { cout<< \"print derived class\" <<endl; } \n" +
"   \n" +
"    void show () \n" +
"    { cout<< \"show derived class\" <<endl; } \n" +
"}; \n" +
"  \n" +
"//main function \n" +
"int main()  \n" +
"{ \n" +
"    base *bptr; \n" +
"    derived d; \n" +
"    bptr = &d; \n" +
"       \n" +
"    //virtual function, binded at runtime (Runtime polymorphism) \n" +
"    bptr->print();  \n" +
"       \n" +
"    // Non-virtual function, binded at compile time \n" +
"    bptr->show();  \n" +
"  \n" +
"    return 0; \n" +
"}  \n" +
"\nOutput:\n" +
"\n" +
"print derived class\n" +
"show base class");
          text.setCaretPosition(0);
    }//GEN-LAST:event_PolymorBActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
      new c(c,"C++").setVisible(true);
      this.setVisible(false);
    }//GEN-LAST:event_formWindowClosing

    
   

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AbstractionB;
    private javax.swing.JButton IntroB;
    private javax.swing.JButton PointerB;
    private javax.swing.JButton PolymorB;
    private javax.swing.JButton arrarB;
    private javax.swing.JButton classobjB;
    private javax.swing.JButton decisionB;
    private javax.swing.JButton elseifB;
    private javax.swing.JButton ifbutton;
    private javax.swing.JButton ifelseB;
    private javax.swing.JButton inheritancB;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JButton nesterdB;
    private javax.swing.JButton oveerloadingB;
    private javax.swing.JButton stringB;
    private javax.swing.JButton stringmaniB;
    private javax.swing.JButton switchB;
    private javax.swing.JTextArea text;
    // End of variables declaration//GEN-END:variables
}
